{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Data Structures Package This package implements fundamental data structures in Python, including Array, LinkedList, Stack, Queue, Graph, and Tree. Classes Included 1. Array A dynamic array implementation similar to Python\u2019s built-in list. Features: append(value) \u2013 Adds an element at the end. insert(index, value) \u2013 Inserts an element at a specific index. delete(index) \u2013 Removes an element at a specific index. search(value) \u2013 Returns the index of the value, or -1 if not found. display() \u2013 Displays the current elements. Automatically resizes when capacity is exceeded. 2. LinkedList A singly linked list with support for insertions, deletions, search, and update. Features: add_Node(data, post=0) \u2013 Adds a new node at the beginning or specified position. delete_Node(data, post=0) \u2013 Deletes a node at the beginning or a given position. search(data) \u2013 Searches for a node and returns its position. get_node(position) \u2013 Returns the node at a given position. update(val, new_val) \u2013 Updates a node's value. display() \u2013 Prints the entire list. 3. Stack A simple stack using a Python list (LIFO). Features: push(data) \u2013 Adds data to the top of the stack. pop() \u2013 Removes and returns the top item. top() \u2013 Returns the current top without removing it. display() \u2013 Prints stack content. size() \u2013 Returns the number of elements. 4. Queue A FIFO queue using a Python list. Features: enqueue(data) \u2013 Adds data to the end. dequeue() \u2013 Removes and returns the front item. is_empty() \u2013 Checks if the queue is empty. size() \u2013 Returns the queue length. display() \u2013 Displays the queue elements. 5. Graph An undirected graph implemented using an adjacency list. Features: add_node(data) \u2013 Adds a new node. add_edge(data1, data2) \u2013 Creates a two-way connection between nodes. display() \u2013 Shows all nodes and their neighbors. 6. Tree A binary search tree (BST) implementation. Features: insert(data) \u2013 Inserts a value into the tree. search(data) \u2013 Searches for a value. in_order() \u2013 Prints the tree in in-order traversal.","title":"Data Structures Package"},{"location":"#data-structures-package","text":"This package implements fundamental data structures in Python, including Array, LinkedList, Stack, Queue, Graph, and Tree.","title":"Data Structures Package"},{"location":"#classes-included","text":"","title":"Classes Included"},{"location":"#1-array","text":"A dynamic array implementation similar to Python\u2019s built-in list.","title":"1. Array"},{"location":"#features","text":"append(value) \u2013 Adds an element at the end. insert(index, value) \u2013 Inserts an element at a specific index. delete(index) \u2013 Removes an element at a specific index. search(value) \u2013 Returns the index of the value, or -1 if not found. display() \u2013 Displays the current elements. Automatically resizes when capacity is exceeded.","title":"Features:"},{"location":"#2-linkedlist","text":"A singly linked list with support for insertions, deletions, search, and update.","title":"2. LinkedList"},{"location":"#features_1","text":"add_Node(data, post=0) \u2013 Adds a new node at the beginning or specified position. delete_Node(data, post=0) \u2013 Deletes a node at the beginning or a given position. search(data) \u2013 Searches for a node and returns its position. get_node(position) \u2013 Returns the node at a given position. update(val, new_val) \u2013 Updates a node's value. display() \u2013 Prints the entire list.","title":"Features:"},{"location":"#3-stack","text":"A simple stack using a Python list (LIFO).","title":"3. Stack"},{"location":"#features_2","text":"push(data) \u2013 Adds data to the top of the stack. pop() \u2013 Removes and returns the top item. top() \u2013 Returns the current top without removing it. display() \u2013 Prints stack content. size() \u2013 Returns the number of elements.","title":"Features:"},{"location":"#4-queue","text":"A FIFO queue using a Python list.","title":"4. Queue"},{"location":"#features_3","text":"enqueue(data) \u2013 Adds data to the end. dequeue() \u2013 Removes and returns the front item. is_empty() \u2013 Checks if the queue is empty. size() \u2013 Returns the queue length. display() \u2013 Displays the queue elements.","title":"Features:"},{"location":"#5-graph","text":"An undirected graph implemented using an adjacency list.","title":"5. Graph"},{"location":"#features_4","text":"add_node(data) \u2013 Adds a new node. add_edge(data1, data2) \u2013 Creates a two-way connection between nodes. display() \u2013 Shows all nodes and their neighbors.","title":"Features:"},{"location":"#6-tree","text":"A binary search tree (BST) implementation.","title":"6. Tree"},{"location":"#features_5","text":"insert(data) \u2013 Inserts a value into the tree. search(data) \u2013 Searches for a value. in_order() \u2013 Prints the tree in in-order traversal.","title":"Features:"}]}